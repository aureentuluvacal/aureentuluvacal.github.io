{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/troubleshooting-db-cpu-error/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Cal Perez"}},"markdownRemark":{"id":"ae1ef6d5-a3bb-5085-bb29-a00bd16d7d5c","excerpt":"A few weeks ago I was seeing a lot of these errors in production: And then production went down. For context, our stack is composed of a Ruby on Rails app withâ€¦","timeToRead":3,"html":"<p>A few weeks ago I was seeing a lot of these errors in production:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">ActiveRecord::ConnectionTimeoutError - could not obtain\na database connection within <span class=\"token number\">5</span> seconds.</code></pre></div>\n<p>And then production went down.</p>\n<p>For context, our stack is composed of a Ruby on Rails app with some React peppered in that is containerized by Docker, orchestrated by Kubernetes, and served up from AWS. We use AWS for our MySQL database instances, too.</p>\n<p>We were getting a lot of 500 errors and users posting about not being able to use the app. I had the error above as a clue that either something was misconfigured (very unlikely since that would have been caught during our QA process) or the database itself was having trouble.</p>\n<p>We went with the second option and opened up RDS in the AWS console. We have an m4.large instance serving up MySQL 5.6 to our production app. The instance was over 100% CPU usage.</p>\n<p>So what do to next?</p>\n<p>I knew from my time at Lessonly, that sometimes thereâ€™s not enough available threads in the database connection pool. I remember reading <a href=\"https://devcenter.heroku.com/articles/concurrency-and-database-connections#connection-pool\">this article on Heroku</a> for insights. The relevant line in here is</p>\n<blockquote>\n<p>Active Record limits the total number of connections per application through a database setting pool; this is the maximum size of the connections your app can have to the database.</p>\n</blockquote>\n<p>I thought that since we have more customers and it was peak usage time then maybe there just wasnâ€™t enough database to go around. And the Heroku article laid out a simple solution, so I edited our <em>database.yml</em> file.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">production</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">&lt;&lt;</span><span class=\"token punctuation\">:</span> <span class=\"token important\">*default</span>\n  <span class=\"token key atrule\">database</span><span class=\"token punctuation\">:</span> iris_app_production\n  <span class=\"token key atrule\">reconnect</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">username</span><span class=\"token punctuation\">:</span> &lt;%= ENV<span class=\"token punctuation\">[</span><span class=\"token string\">'RAILS_DB_USER'</span><span class=\"token punctuation\">]</span> %<span class=\"token punctuation\">></span>\n  <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> &lt;%= ENV<span class=\"token punctuation\">[</span><span class=\"token string\">'RAILS_DB_PASS'</span><span class=\"token punctuation\">]</span> %<span class=\"token punctuation\">></span>\n  <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> &lt;%= ENV<span class=\"token punctuation\">[</span><span class=\"token string\">'RAILS_DB_HOST'</span><span class=\"token punctuation\">]</span> %<span class=\"token punctuation\">></span>\n  <span class=\"token key atrule\">pool</span><span class=\"token punctuation\">:</span> 1Ì¶0Ì¶ 40 <span class=\"token comment\"># Just to be dramatic.</span></code></pre></div>\n<p>That didnâ€™t do much after it was deployed so we nixed that, especially since it didnâ€™t explain the massive amount of CPU usage. The next thing we could do was narrow down where the problem was coming from. That meant temporarily disabling cron jobs to see if the source was a specific cron job or the main Rails app itself. We have four cron jobs: a daily job that runs in the early AM, an hourly job, and two every-5-minute jobs.</p>\n<p>The daily job could be dismissed off the bat because it had already run. The other jobs we disabled one by one to see if helped CPU consumption.</p>\n<p>But that didnâ€™t work either. We saw no drop in CPU usage. The source of the problem was definitely with the app itself. At this point, an hour had already passed and I was stressed out of my fucking mind because production was down. Not a great feeling and I had to fix it regardless.</p>\n<p>I decided to switch tactics and try to investigate the actual queries that were running on the database. I connected to the production database and typed in</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SHOW</span> PROCESSLIST</code></pre></div>\n<p>This gave me back a table of all the active threads that were running in the production database.</p>\n<p>(In retrospect, I should have started with this but Â¯\\<em>(ãƒ„)\\</em>/Â¯).</p>\n<p>The most relevant columns <code class=\"language-text\">SHOW PROCESSLIST</code> gives back are:</p>\n<ul>\n<li><strong>Command</strong>: the command the thread is executing in the DB\n<ul>\n<li>Read more <a href=\"https://dev.mysql.com/doc/refman/8.0/en/thread-commands.html\">here</a></li>\n</ul>\n</li>\n<li><strong>Time</strong>: the time in seconds the command is taking to execute</li>\n<li><strong>Info</strong>: the statement the thread is executing</li>\n</ul>\n<p>This was it.</p>\n<p>We had several rows stuck on execution with the same type of query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> communications\n<span class=\"token keyword\">WHERE</span> communications<span class=\"token punctuation\">.</span>access_token <span class=\"token operator\">=</span> <span class=\"token string\">\"EXAMPLE\"</span></code></pre></div>\n<p>The communications table had almost 600k records, which isnâ€™t a lot of records for a properly indexed table to perform a lookup. And lo and behold, the table wasnâ€™t indexed by the column <strong>access_token</strong>. All that was left was to create a migration:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">AddIndexToCommunications</span> <span class=\"token operator\">&lt;</span> ActiveRecord<span class=\"token double-colon punctuation\">::</span>Migration\n  disable_ddl_transaction<span class=\"token operator\">!</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">change</span></span>\n    add_index <span class=\"token symbol\">:communications</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:access_token</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">algorithm</span><span class=\"token operator\">:</span> <span class=\"token symbol\">:inplace</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>We use the algorithm <code class=\"language-text\">:inplace</code> to prevent the table from locking as its being indexed â€” the app still needs to use the table! If youâ€™re using PostgresQL then use the algorithm <code class=\"language-text\">:concurrently</code>. Since adding concurrent indexes canâ€™t be wrapped in transaction, we need <code class=\"language-text\">disable_ddl_transaction!</code>.</p>\n<p>After the migration was deployed and run, CPU usage dropped from 100% to 2% when jobs werenâ€™t running, which is insane. This is why we properly index tables.</p>","frontmatter":{"title":"Troubleshooting Rails Database Connection Issue","date":"October 13, 2019","description":"Production died then I fixed it.","subtitle":null,"tags":["Code"]}}},"pageContext":{"slug":"/troubleshooting-db-cpu-error/","previous":{"fields":{"slug":"/job-update/"},"frontmatter":{"title":"ðŸŽ‰ I'm a CTO Now! ðŸŽ‰","subtitle":null}},"next":{"fields":{"slug":"/goals-for-blog/"},"frontmatter":{"title":"Goals for this Blog","subtitle":null}}}},
    "staticQueryHashes": ["3000541721"]}