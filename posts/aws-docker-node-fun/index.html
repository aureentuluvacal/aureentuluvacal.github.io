<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<link rel="icon" href="../../favicon.ico" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link
		href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Rubik:ital,wght@0,300..900;1,300..900&display=swap"
		rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<!-- Katex -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
		integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">

	
		<link href="../../_app/immutable/assets/0.0aUjidVN.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/3.jv80lpkj.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.jB-4DnvD.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/main-client.0o2Jgazd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/runtime.n4xba1mo.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons.WW5OPqyQ.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/paths.5ROn4zJg.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.BDz8IuSA.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/preload-helper.0HuHagjb.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/disclose-version.kKvJJDcG.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.05hzbzow.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/3.vf4oIYoF.js"><title>Having a fun (and terrible) time with AWS, Docker, and Node</title><!--ssr:0--><!--ssr:0-->
</head>

<body data-sveltekit-preload-data="hover">
	<div style="display: contents">
		<div id="header-container">
			<h1>Cal Perez</h1>
			<p>
				Senior Software Engineer. I also like to cook, paint, and play D&D and
				Warhammer RPG.
			</p>
		</div>
		<div id="content-container">
			<!--ssr:0--><!--ssr:1--><!--ssr:if:true--><!--ssr:3--><div class="container"><!--ssr:4--><!--ssr:5--><div><article class="svelte-k80i5u"><header><h1>Having a fun (and terrible) time with AWS, Docker, and Node</h1> <!--ssr:6--><!--ssr:if:false--><!--ssr:6--> <h5>June 26, 2020</h5></header> <div id="post-content" class="svelte-k80i5u"><!--ssr:7--><div><!--ssr:10-->
<p>We're doing a three month feature freeze at Iris to address our technical debt, refine processes, and create enablement for the entire team. There's a very long story to this, but the main gist is weight of years old technical debt was taking its toll. We're spending these three months very wisely to improve everything and it's honestly one of the most refreshing professional experiences I've had.</p>
<p>One of our projects is an app that enables the support team to have all the data they need to address customer issues. Our bug escalation process has three tiers: the CS team, my CEO, then the dev team. (Remember, we're a team of seven so there's a lot of hat wearing.)</p>
<p>Typically, if it requires database access and SQL knowledge to verify certain details, my CEO will takeover and potentially escalate if the issue is clearly a bug in our code. Understandably, it takes time to triage bugs and fill in the next tier about what's going on. Therefore, our goal is to limit escalations to save everyone's time and energy.</p>
<p>As an added bonus, we'd also experience that particular giddiness developers get when starting a new project.</p>
<h2>The architecture</h2>
<p>We already use AWS, Docker, and Kubernetes for our app so it made sense to use at least AWS and Docker. Kubernetes felt like overkill for something only two people would access for now. I had already created a repo in Gitlab to house the code for two separate apps. One for the React app that they'd interact with and one for the Node app that would act as its API.</p>
<blockquote>
<p>I could have made it one app that did server-side rendering but we're already doing that with Rails for the main app and I wanted to do something new.</p>
</blockquote>
<p>In my head the architecture looked like this:</p>
<p><img src="https://s3.us-east-2.amazonaws.com/caryssa-perez-images/posts/supportal-architecture-1.jpg" alt="First version of the architecture"></p>
<p>I Dockerized the apps with no problems and, with that momentum, plunged into AWS. First, I booted up one t2.micro instance in EC2 and a t2.micro instance in RDS running MySQL. We use Route 53 for all our <em>*.iris-works.com</em> sites, so a new subdomain that pointed to the EC2 instance was just a simple paste of the public IPv4 address of the instance.</p>
<p>I tried to access the new site that pointed to the React app and got nothing. Then for the next several hours I struggled. It was one of those moments where I understood from a high level what was going on, but then also had no idea what was going on.</p>
<p>My frantic Googling didn't help really since the various Medium and StackOverflow posts didn't include exactly everything I was using or didn't use them in the same way and it only confused me more. Why can't I see the index file when I attempt to load the site? What the hell was Elastic Beanstalk? Why would I need a load balancer?</p>
<p>I left work that day frustrated because it started out so well. I hoped that night I'd dream up a solution, but my brain instead subjected me to one of those choppy and disturbing marathon dreams that had me questioning my reality. Because why not.</p>
<p><img src="https://media.giphy.com/media/1412QM7NaCZMyc/giphy.gif" alt="Inception gif of Cobb saying 'It's only when we wake up that we realize something was actually strange.'"></p>
<p>The next day, I started over and questioned my fundamental understanding of all the technologies I was using, especially the ones I needed under Amazon's wide umbrella.</p>
<p>I felt comfortable with React, Node, Typescript, and Docker. However, I was bootstrapping the app with Create React App and I needed to read more on how to deploy a production build. It was then I started to realize that I was running a container that was doing nothing except storing static files. I needed a simple server underneath it to, you know, actually serve up the files. A novel concept.</p>
<p>In development, when you run <code>yarn start</code> or <code>react-scripts start</code> it uses Webpack to bundle static assets, which are then served up by the WebpackDevServer, which you then access with your browser, the client. In EC2 land, instances are just empty hunks of circuitry and metal. And when I add Docker to the mix, it will only install what I tell it to, so the containers that result are just as empty. In other words, if I don't install anything to serve the files, then they won't serve. I needed a simple server like nginx.</p>
<pre><code class="language-bash"><span class="hljs-comment"># Use the latest node and alias for temporary use.</span>
FROM node:14.4 as build

<span class="hljs-comment"># Create directory for the container.</span>
WORKDIR /client

<span class="hljs-comment"># Only copy the package.json file to work directory.</span>
ADD package.json /client/package.json

<span class="hljs-comment"># Install all packages.</span>
RUN yarn install

<span class="hljs-comment"># Copy all other source code to work directory.</span>
ADD . /supportal_client

<span class="hljs-comment"># Build static assets.</span>
RUN yarn build

<span class="hljs-comment"># Run in nginx.</span>
FROM nginx:stable-alpine

COPY --from=build /client/build /usr/share/nginx/html
COPY nginx/nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]
</code></pre>
<p>I redeployed my changes and reloaded the site and boom, I saw an actual page. The only problem was that it was serving on HTTP only despite the security group allowing incoming traffic on port 443 for HTTPS.</p>
<p>Obviously, I had pieces missing and I wanted to turn back to AWS instead of figuring out how to add SSL to my nginx config.</p>
<h2>My new understanding of AWS</h2>
<p>I still had this fuzziness in my knowledge of <em>how</em> everything was working together in AWS and what services I actually needed.</p>
<p>I had a Route 53 record pointing to an EC2 instance that only handled traffic on port 80 for HTTP requests and SSH traffic for me. In the various articles I read, ALBs, port forwarding, and target groups kept coming up. I didn't know what any of this was until yesterday. (I'm not a devops or networking person so a lot of this was handwaved away.)</p>
<p>Anyway, I know EC2 instances are just someone else's servers and that security groups allow specific kinds of traffic to those servers. If I wanted to get actual traffic via HTTPS I needed to add an Application Load Balancer (ALB), which is AWS's new, specialized version of an Elastic Load Balancer (ELB). ALBs or ELBs are basically guardsmen that redirect internet traffic to an EC2 instance.</p>
<p>I could take advantage of the ALB to handle HTTPS requests then forward to the running nginx container. ALBs set this up with target groups, which are also under the EC2 service page, to redirect to specific ports for the destination server. My target group had to point to port 80 for HTTP and HTTPS requests. All I had left to do was point the Route 53 record to the new ALB.</p>
<p>After all this clicked, the architecture looks more like this:</p>
<p><img src="https://s3.us-east-2.amazonaws.com/caryssa-perez-images/posts/supportal-architecture-2.jpg" alt="Second version of the architecture"></p>
<p>It felt good to finally see the site over HTTPS. Now I can actually build the damn thing and I'm super excited for it. Typescript, React, TypeORM, GraphQL; it's going to be good.</p>
<p>Also, in retrospect, I realize that Elastic Beanstalk could have done all of this for me, but where's the fun in that?</p>
<!--ssr:10--></div><!--ssr:7--></div> <div class="post-controlContainer"><!--ssr:8--><!--ssr:if:true--><a href="../../posts/logic" target="_self" class="post-control svelte-k80i5u"><p class="svelte-k80i5u"><i class="icons-arrow icons-arrow--left svelte-k80i5u"></i> Previous</p> <p class="svelte-k80i5u">Logic</p></a><!--ssr:8--> <!--ssr:9--><!--ssr:if:true--><a href="../../posts/logic-part-2" target="_self" class="post-control svelte-k80i5u" style="text-align: right;"><p class="svelte-k80i5u">Next <i class="icons-arrow icons-arrow--right svelte-k80i5u"></i></p> <p class="svelte-k80i5u">2 Logic 2 Furious</p></a><!--ssr:9--></div></article></div><!--ssr:5--><!--ssr:4--></div><!--ssr:3--><!--ssr:1--> <!--ssr:2--><!--ssr:if:false--><!--ssr:2--><!--ssr:0-->
			
			<script>
				{
					__sveltekit_wuqgm6 = {
						base: new URL("../..", location).pathname.slice(0, -1),
						env: null
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":{post:{title:"Having a fun (and terrible) time with AWS, Docker, and Node",date:"2020-06-27T00:00:00.000Z",description:"Who would have thought there'd be so many pieces to getting a basic app setup on AWS.",tags:["Code"],slug:"aws-docker-node-fun",next:{title:"2 Logic 2 Furious",description:"More complicated propositional logic!",date:"2020-07-18T00:00:00.000Z",tags:["Math"],slug:"logic-part-2"},previous:{title:"Logic",description:"This was my favorite course at Purdue. I'm just going to nerd out over it for a bit.",date:"2020-06-09T00:00:00.000Z",tags:["Math"],slug:"logic"}}},"uses":{"params":["slug"]}}];

					Promise.all([
						import("../../_app/immutable/entry/start.jB-4DnvD.js"),
						import("../../_app/immutable/entry/app.BDz8IuSA.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		
		</div>
	</div>
</body>

</html>
